ETF Atlas — PostgreSQL 하나로 그래프 + 벡터 + 실시간 알림까지

===================================
발단: "그래프 DB로 뭔가 만들어보고 싶다"
===================================

시작은 단순한 기술적 호기심이었다.
Apache AGE라는 PostgreSQL 기반 그래프 DB 확장이 눈에 띄었고,
smolagents라는 Hugging Face의 경량 AI 에이전트 프레임워크도 궁금했다.
"이 두 가지를 엮어서 실제 서비스를 만들어보면 어떨까?"

마침 평소 ETF 투자를 하면서 궁금했던 게 있었다.
"삼성전자를 가장 많이 담은 ETF는 뭘까?"
"액티브 ETF 운용사들이 요즘 어떤 종목을 사고 팔까?"

이 질문들은 본질적으로 관계 탐색 문제다.
ETF와 종목 사이의 다대다(N:M) 관계, 운용사-ETF-종목의 연결고리.
RDB의 JOIN으로도 풀 수 있지만, 그래프로 표현하면 훨씬 직관적이다.

그래서 2월 1일, 첫 커밋을 찍었다.
결과적으로 18일 동안 79개의 커밋이 쌓였고,
PostgreSQL 하나에 5개 확장(AGE, pgvector, pg_trgm, pg_notify, RDB)이
공존하는 하이브리드 아키텍처가 만들어졌다.

git log: db2d713 first commit (2026-02-01)


===================================
1장: Apache AGE — Neo4j 없이 그래프를 쓰다
===================================

Neo4j는 그래프 DB의 대명사다. 다들 이름은 들어봤을 것이다.
그런데 Neo4j를 쓰려면 별도 서버를 운영해야 한다.
사이드 프로젝트에 DB 서버를 하나 더 띄우기는 부담스러웠다.

Apache AGE(Apache AGraph Extension)는 다른 접근을 취한다.
PostgreSQL 확장(extension)으로 동작하기 때문에
이미 쓰고 있는 PostgreSQL에 CREATE EXTENSION 한 줄이면 그래프 DB가 생긴다.
별도 서버 불필요, 라이선스도 Apache 2.0으로 완전 무료.

쿼리 언어는 Neo4j와 같은 Cypher를 지원한다.
다만 실행 방식이 다르다. Neo4j에서는 Cypher를 직접 실행하지만,
AGE에서는 SQL 함수 안에 Cypher를 감싸서 실행한다:

  SELECT * FROM cypher('etf_graph', $$
      MATCH (e:ETF)-[h:HOLDS]->(s:Stock)
      RETURN {etf: e.name, stock: s.name, weight: h.weight}
  $$) AS (result agtype);

SQL과 Cypher가 한 쿼리 안에 공존하는 셈이다.
같은 PostgreSQL 안에서 SQL 테이블과 그래프를 동시에 다룰 수 있다는 것이
AGE의 가장 큰 장점이다.

이 프로젝트에서는 ETF-종목 관계를 7종 노드, 6종 관계의 그래프로 모델링했다.
ETF가 어떤 종목을 보유하는지(HOLDS), 어떤 운용사가 관리하는지(MANAGED_BY),
어떤 태그에 속하는지(TAGGED), 가격은 얼마인지(HAS_PRICE).

"삼성전자를 담은 ETF는?"이라는 질문은 Cypher로 이렇게 표현된다:

  MATCH (e:ETF)-[h:HOLDS]->(s:Stock {code: '005930'})
  RETURN {etf: e.name, weight: h.weight}
  ORDER BY h.weight DESC

RDB로도 가능하지만, Cypher가 읽는 사람 입장에서 훨씬 직관적이다.

git log: a0d8314 feat: Implement ETF Atlas v1 (2026-02-01)


===================================
2장: AGE + SQLAlchemy — 공존의 어려움
===================================

AGE의 장점은 PostgreSQL과 한 지붕 아래 산다는 것이다.
하지만 한 지붕 아래 살다 보면 부딪히는 것도 있다.
FastAPI 백엔드에서 SQLAlchemy로 AGE를 다루면서 세 가지 충돌을 만났다.

첫 번째, 콜론 충돌.
SQLAlchemy의 text() 함수는 :WORD를 바인드 파라미터로 인식한다.
그런데 Cypher에는 :ETF, [:HOLDS] 같은 레이블 표기가 가득하다.
쿼리를 실행하면 "missing parameter :ETF" 에러가 터진다.
해결 방법은 단순하지만 우아하지 않다.
모든 콜론을 \:로 이스케이프하는 전처리를 추가했다.

두 번째, 파라미터 표기 충돌.
Cypher는 $param을 쓰고, SQLAlchemy는 :param을 쓴다.
같은 쿼리 안에 두 문법이 섞이면 혼돈이 온다.
결국 $param 값을 직접 문자열로 치환한 뒤 실행하는 방식을 택했다.

세 번째, MERGE + SET 버그.
AGE 1.5.0에서 MERGE와 SET을 한 쿼리에 쓰면 에러가 난다.
공식 문서에는 안 나와 있는 버그다.
MERGE로 노드를 생성하고, 별도 쿼리에서 MATCH + SET으로 속성을 설정하는
2단계 분리 패턴을 만들었다.

이 세 가지를 파악하는 데 이틀이 걸렸다.
하지만 한번 패턴이 잡히니 이후에는 빠르게 개발할 수 있었다.

최종적으로 execute_cypher라는 함수가 이 모든 걸 처리한다:
$param을 실제 값으로 치환하고, SQL로 래핑하고, 콜론을 이스케이프한 뒤 실행.
Neo4j 드라이버처럼 편하지는 않지만,
같은 PostgreSQL 안에서 그래프와 RDB를 동시에 쓸 수 있다는 이점이 크다.

git log: 975640a feat: KRX API 클라이언트 모듈화 (2026-02-03)


===================================
3장: 하이브리드의 탄생 — 한 가지 DB로는 안 된다 (2/9)
===================================

처음에는 AGE에 올인했다.
ETF 목록, 보유종목, 가격 데이터, 심지어 검색까지 전부 그래프에 넣었다.

그런데 "KODEX 200"을 검색하는데 전체 그래프를 스캔하는 건 너무 느렸다.
그래프는 관계 탐색에 강하지만, 단순 텍스트 검색에는 RDB가 훨씬 빠르다.

결국 RDB에 etfs 테이블을 따로 만들고, pg_trgm 확장으로 한글 퍼지 검색을 구현했다.
pg_trgm은 문자열을 3글자 단위(trigram)로 쪼개서 유사도를 계산하는 PostgreSQL 확장이다.
"코덱스"로 검색해도 "KODEX"가 나오는 식.

이때 역할 분담이 정리됐다:
- ETF-종목 관계 → AGE (그래프 탐색에 강함)
- ETF 메타데이터/검색 → RDB + pg_trgm (텍스트 검색에 강함)
- 사용자/포트폴리오/인증 → RDB (CRUD에 강함)

"한 가지 DB로 모든 걸 해결하겠다"는 것은 환상이었다.
하지만 PostgreSQL은 확장 생태계 덕분에
하나의 DB 서버 안에서 여러 역할을 동시에 수행할 수 있었다.
인프라는 하나, 역할은 여럿. 이것이 하이브리드 아키텍처의 핵심이다.

git log: f056fae feat: RDB etfs 테이블 + pg_trgm 검색으로 ETF 검색 기능 구현 (2026-02-09)


===================================
4장: smolagents — AI 에이전트가 그래프를 탐색하다 (2/11)
===================================

Hugging Face의 smolagents는 LLM에게 도구(Tool)를 주고
스스로 판단하여 호출하게 하는 경량 에이전트 프레임워크다.
LangChain보다 가볍고 단순해서 사이드 프로젝트에 붙이기 좋았다.

ETF Atlas 챗봇에는 이런 도구들을 등록했다:
- get_etf_info: AGE에서 ETF 상세 정보 조회
- get_etf_prices: AGE Price 노드에서 가격 조회
- search_etf: RDB pg_trgm으로 퍼지 검색
- get_etf_holdings: AGE에서 보유종목 비중 조회
- get_similar_etfs: 보유종목 겹침도 기반 유사 ETF 탐색

사용자가 "보수율 낮은 반도체 ETF 추천해줘"라고 물으면,
에이전트가 search_etf("반도체")를 호출하고, 결과에서 보수율을 정렬해서 답변한다.
도구를 어떤 순서로 호출할지, 결과를 어떻게 조합할지는 LLM이 판단한다.

git log: dda96d7 feat: ETF 챗봇 기능 추가 (smolagents + Apache AGE) (2026-02-11)


===================================
5장: pg_notify — 별도 인프라 없이 실시간 알림 (2/17)
===================================

"ETF 보유종목 비중이 바뀌면 알려줘."

이 기능을 구현하려면 이벤트 기반 아키텍처가 필요하다.
보통은 Redis Pub/Sub나 RabbitMQ, Kafka 같은 메시지 브로커를 떠올린다.
하지만 사이드 프로젝트에 메시지 큐 서버까지 추가하기는 과했다.

PostgreSQL에는 pg_notify라는 내장 기능이 있다.
별도 인프라 없이 PostgreSQL 자체가 메시지 브로커 역할을 한다.

원리는 단순하다:
- LISTEN: 특정 채널을 구독한다
- NOTIFY: 채널에 메시지를 보낸다

  -- 구독 (백엔드가 실행)
  LISTEN new_collection;

  -- 발행 (Airflow DAG가 실행)
  NOTIFY new_collection, '2026-02-18';

처음에는 SSE(Server-Sent Events)를 30초 폴링으로 구현했다.
30초마다 "새 알림 있어?" 하고 DB를 조회하는 방식.
동작은 하지만 사실상 polling이지 진짜 push가 아니었다.

pg_notify로 전환한 뒤의 흐름은 이렇다:
1. Airflow DAG가 데이터 수집을 완료한다
2. collection_runs 테이블에 기록하고, NOTIFY new_collection 발행
3. FastAPI 백엔드가 LISTEN하고 있다가 이벤트를 수신
4. SSE 스트림으로 프론트엔드에 즉시 전달
5. 프론트엔드가 알림 뱃지를 업데이트

중복 알림 방지도 PostgreSQL 기능으로 해결했다.
INSERT ... ON CONFLICT DO NOTHING으로 이미 수집된 날짜면 NOTIFY를 생략한다.

디스코드 웹훅도 추가해서 관리자는 디스코드에서도 알림을 받는다.
pg_notify는 소규모 서비스에서 과소평가된 기능이다.
Redis 없이도 충분히 실시간 이벤트를 처리할 수 있다.

git log: 7e4855a feat: SSE 30초 폴링을 pg_notify LISTEN 기반으로 변경 (2026-02-17)
git log: 4e5a5d5 fix: 수동 트리거 시 중복 알림 방지 (2026-02-17)


===================================
6장: pgvector — LLM에게 AGE용 Cypher를 가르치다 (2/18)
===================================

챗봇의 가장 큰 약점은 Cypher 쿼리 정확도였다.
LLM은 Neo4j 기준으로 Cypher를 생성한다.
하지만 AGE의 Cypher는 미묘하게 다르다:
- cypher() 함수의 반환은 단일 agtype 컬럼이라 RETURN을 맵으로 감싸야 한다
- 날짜별 HOLDS 엣지에서 최신만 추출하려면 ORDER BY + head(collect()) 패턴이 필요하다
- MERGE + SET은 분리해서 써야 한다

시스템 프롬프트에 규칙을 텍스트로 적어줘도 LLM이 잘 따르지 않았다.
"이런 패턴을 쓰세요"라고 설명하는 것보다
"이런 질문에는 이런 쿼리를 쓰면 됩니다"라고 예제를 보여주는 게 효과적이었다.

그래서 pgvector를 도입했다.
pgvector는 PostgreSQL에서 벡터 유사도 검색을 지원하는 확장이다.
텍스트를 벡터(숫자 배열)로 변환해서 저장하고,
코사인 유사도(<=> 연산자)로 가장 비슷한 벡터를 찾을 수 있다.

구현 흐름:
1. 100개의 "질문 → 올바른 AGE Cypher" 예제를 준비
2. 각 질문을 OpenAI text-embedding-3-small로 1536차원 벡터로 변환
3. cypher_examples 테이블에 질문, Cypher, 임베딩 벡터를 저장
4. IVFFlat 인덱스를 걸어서 빠른 유사도 검색 지원

사용자가 질문하면:
1. 질문을 벡터로 변환
2. pgvector로 가장 유사한 예제 3개를 검색 (코사인 거리 기준)
3. 찾은 예제를 프롬프트에 "참고 Cypher 예시"로 주입
4. LLM이 예제를 보고 AGE에 맞는 Cypher를 생성

  ## 참고 Cypher 쿼리 예시
  Q: 삼성전자를 담은 ETF는?
  ```cypher
  MATCH (e:ETF)-[h:HOLDS]->(s:Stock {code: '005930'})
  WITH e, h ORDER BY h.date DESC
  WITH e, head(collect(h)) as latest
  RETURN {etf: e.name, weight: latest.weight}
  ```

  ## 현재 질문:
  반도체 관련 ETF 중에서 삼성전자 비중이 가장 높은 건?

이것이 Few-Shot RAG(Retrieval-Augmented Generation) 패턴이다.
시스템 프롬프트로 규칙을 설명하는 것보다
실제 예제를 검색해서 보여주는 것이 LLM에게 훨씬 효과적이라는 걸 배웠다.

여기서도 SQLAlchemy 콜론 충돌이 등장한다.
pgvector의 타입 캐스팅 ::vector가 SQLAlchemy에서 :vector 파라미터로 인식되므로
\:\:vector로 이스케이프해야 한다. AGE에서 배운 교훈이 여기서도 재활용됐다.

git log: 45b226f feat: add cypher_examples table with pgvector (2026-02-18)
git log: ef4cc2b feat: add 100 cypher few-shot examples seed data (2026-02-18)
git log: bed89ba feat: integrate few-shot example selector into ChatService prompt (2026-02-18)


===================================
에필로그: PostgreSQL의 가능성
===================================

2월 1일 첫 커밋부터 2월 18일까지, 총 79개의 커밋.
15일간의 개발. (주말 포함, 평일 업무 후 작업)

이 프로젝트에서 가장 인상적이었던 것은
PostgreSQL 하나로 이렇게 많은 일을 할 수 있다는 것이다.

- Apache AGE: ETF-종목 관계를 그래프로 탐색
- pgvector: 챗봇 few-shot 예제를 벡터로 검색
- pg_trgm: 한글 ETF 이름을 퍼지 검색
- pg_notify: 데이터 수집 완료를 실시간으로 알림
- RDB: 사용자, 포트폴리오, 인증 데이터 관리

각각의 전문 도구(Neo4j, Pinecone, Elasticsearch, Redis Pub/Sub)보다는 못하다.
하지만 사이드 프로젝트, 혹은 소규모 서비스에서는
인프라 단순성의 가치가 개별 성능보다 클 때가 많다.
서버 하나, DB 하나로 그래프 + 벡터 + 전문검색 + 실시간 알림이 된다.

만든 것:
- 국내 ETF 유니버스를 그래프로 탐색할 수 있는 서비스
- 자연어로 ETF 데이터를 질의할 수 있는 AI 챗봇
- 보유종목 비중 변화를 실시간 알림으로 받을 수 있는 시스템
- 개인 포트폴리오 수익률 대시보드

이제 이걸 같이 써보면서 피드백을 받으려 한다.
