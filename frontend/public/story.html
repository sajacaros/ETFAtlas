<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ETF Atlas Story</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@300;400;500;600;700&family=Fira+Code:wght@400;500&display=swap" rel="stylesheet">
<style>
  :root {
    --primary: #2563eb;
    --primary-light: #dbeafe;
    --primary-dark: #1d4ed8;
    --accent: #f59e0b;
    --accent-light: #fef3c7;
    --bg: #fafbfc;
    --surface: #ffffff;
    --text: #1e293b;
    --text-secondary: #64748b;
    --border: #e2e8f0;
    --code-bg: #f1f5f9;
    --green: #059669;
    --green-light: #d1fae5;
    --red: #dc2626;
    --red-light: #fee2e2;
    --purple: #7c3aed;
    --purple-light: #ede9fe;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    font-family: 'Noto Sans KR', -apple-system, sans-serif;
    background: var(--bg);
    color: var(--text);
    line-height: 1.8;
    font-size: 16px;
  }

  /* ── Header ── */
  header {
    position: fixed; top: 0; left: 0; right: 0; z-index: 100;
    background: rgba(255,255,255,0.95);
    backdrop-filter: blur(8px);
    border-bottom: 1px solid var(--border);
    padding: 0 24px;
    height: 56px;
    display: flex; align-items: center; justify-content: space-between;
  }
  header h1 {
    font-size: 18px; font-weight: 700; color: var(--primary);
    display: flex; align-items: center; gap: 8px;
  }
  header h1 span { font-weight: 400; color: var(--text-secondary); font-size: 14px; }

  /* ── Navigation ── */
  .nav-controls {
    display: flex; align-items: center; gap: 12px;
  }
  .nav-btn {
    width: 36px; height: 36px; border-radius: 8px;
    border: 1px solid var(--border); background: var(--surface);
    display: flex; align-items: center; justify-content: center;
    cursor: pointer; color: var(--text); transition: all 0.15s;
    font-size: 18px;
  }
  .nav-btn:hover:not(:disabled) { border-color: var(--primary); color: var(--primary); }
  .nav-btn:disabled { opacity: 0.3; cursor: default; }
  .page-info { font-size: 13px; color: var(--text-secondary); min-width: 50px; text-align: center; }

  /* ── TOC sidebar ── */
  .toc {
    position: fixed; top: 56px; left: 0; bottom: 0; width: 260px;
    background: var(--surface); border-right: 1px solid var(--border);
    overflow-y: auto; padding: 20px 0;
  }
  .toc-item {
    display: block; padding: 10px 24px; font-size: 14px;
    color: var(--text-secondary); cursor: pointer;
    border-left: 3px solid transparent; transition: all 0.15s;
    text-decoration: none;
  }
  .toc-item:hover { color: var(--text); background: var(--bg); }
  .toc-item.active {
    color: var(--primary); font-weight: 600;
    border-left-color: var(--primary); background: var(--primary-light);
  }
  .toc-num {
    display: inline-block; width: 22px; font-size: 12px;
    color: var(--text-secondary); font-weight: 500;
  }

  /* ── Main content ── */
  main {
    margin-left: 260px; margin-top: 56px;
    min-height: calc(100vh - 56px);
    display: flex; flex-direction: column;
  }
  .chapter {
    display: none; flex: 1;
    max-width: 760px; width: 100%;
    margin: 0 auto; padding: 48px 40px 120px;
  }
  .chapter.active { display: block; }

  /* ── Chapter title ── */
  .chapter-title {
    font-size: 28px; font-weight: 700; color: var(--text);
    margin-bottom: 8px;
  }
  .chapter-num {
    font-size: 13px; font-weight: 600; color: var(--primary);
    text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px;
  }
  .chapter-divider {
    height: 3px; width: 48px; background: var(--primary);
    border-radius: 2px; margin: 16px 0 36px;
  }

  /* ── Subsection ── */
  .sub-title {
    font-size: 20px; font-weight: 600; color: var(--text);
    margin: 44px 0 16px;
    padding-left: 14px; border-left: 4px solid var(--primary);
  }

  /* ── Paragraph ── */
  p { margin: 12px 0; color: var(--text); line-height: 1.85; }

  /* ── Highlights ── */
  .hl { background: var(--accent-light); padding: 1px 5px; border-radius: 3px; font-weight: 500; }
  .hl-blue { background: var(--primary-light); padding: 1px 5px; border-radius: 3px; font-weight: 500; color: var(--primary-dark); }
  .hl-green { background: var(--green-light); padding: 1px 5px; border-radius: 3px; font-weight: 500; color: var(--green); }
  .hl-purple { background: var(--purple-light); padding: 1px 5px; border-radius: 3px; font-weight: 500; color: var(--purple); }

  .tech { font-family: 'Fira Code', monospace; font-size: 0.9em; background: var(--code-bg); padding: 2px 6px; border-radius: 4px; color: var(--primary-dark); }

  /* ── Code block ── */
  pre {
    background: var(--code-bg); border: 1px solid var(--border);
    border-radius: 8px; padding: 20px 24px; margin: 16px 0;
    overflow-x: auto; font-family: 'Fira Code', monospace;
    font-size: 13.5px; line-height: 1.7; color: #334155;
  }

  /* ── Lists ── */
  ul { margin: 12px 0; padding-left: 8px; list-style: none; }
  ul li {
    position: relative; padding-left: 20px; margin: 8px 0;
    color: var(--text); line-height: 1.75;
  }
  ul li::before {
    content: ''; position: absolute; left: 4px; top: 11px;
    width: 6px; height: 6px; border-radius: 50%;
    background: var(--primary);
  }

  /* ── Callout / Key point ── */
  .callout {
    background: var(--primary-light); border-left: 4px solid var(--primary);
    border-radius: 0 8px 8px 0; padding: 16px 20px; margin: 20px 0;
    font-weight: 500; color: var(--primary-dark); line-height: 1.75;
  }
  .callout-warn {
    background: var(--accent-light); border-left: 4px solid var(--accent);
    border-radius: 0 8px 8px 0; padding: 16px 20px; margin: 20px 0;
    line-height: 1.75;
  }
  .callout-green {
    background: var(--green-light); border-left: 4px solid var(--green);
    border-radius: 0 8px 8px 0; padding: 16px 20px; margin: 20px 0;
    line-height: 1.75;
  }

  /* ── Comparison table ── */
  .compare {
    display: grid; grid-template-columns: 1fr 1fr; gap: 16px; margin: 20px 0;
  }
  .compare-card {
    border: 1px solid var(--border); border-radius: 10px;
    padding: 20px; background: var(--surface);
  }
  .compare-card h4 {
    font-size: 15px; font-weight: 700; margin-bottom: 10px;
    display: flex; align-items: center; gap: 6px;
  }
  .compare-card p, .compare-card li { font-size: 14px; }

  /* ── Bottom nav ── */
  .bottom-nav {
    position: fixed; bottom: 0; left: 260px; right: 0;
    background: rgba(255,255,255,0.95); backdrop-filter: blur(8px);
    border-top: 1px solid var(--border);
    padding: 12px 40px; display: flex; justify-content: space-between; align-items: center;
  }
  .bottom-btn {
    padding: 8px 20px; border-radius: 8px; border: 1px solid var(--border);
    background: var(--surface); cursor: pointer; font-size: 14px;
    color: var(--text); transition: all 0.15s; font-family: 'Noto Sans KR', sans-serif;
    display: flex; align-items: center; gap: 6px;
  }
  .bottom-btn:hover:not(:disabled) { border-color: var(--primary); color: var(--primary); }
  .bottom-btn:disabled { opacity: 0.3; cursor: default; }
  .bottom-btn.primary {
    background: var(--primary); color: white; border-color: var(--primary);
  }
  .bottom-btn.primary:hover { background: var(--primary-dark); }

  /* ── Dots ── */
  .dots { display: flex; gap: 6px; align-items: center; }
  .dot {
    width: 8px; height: 8px; border-radius: 50%;
    background: var(--border); cursor: pointer; transition: all 0.15s;
    border: none;
  }
  .dot.active { background: var(--primary); transform: scale(1.3); }
  .dot:hover:not(.active) { background: var(--text-secondary); }

  /* ── Review cards ── */
  .review-card {
    border: 1px solid var(--border); border-radius: 10px;
    padding: 24px; margin: 16px 0; background: var(--surface);
  }
  .review-card h4 {
    font-size: 17px; font-weight: 700; margin-bottom: 12px;
    display: flex; align-items: center; gap: 8px;
  }
  .review-section { margin: 8px 0; }
  .review-label {
    font-size: 13px; font-weight: 600; margin-bottom: 4px;
    display: flex; align-items: center; gap: 4px;
  }
  .review-label.good { color: var(--green); }
  .review-label.bad { color: var(--red); }
  .review-label.rec { color: var(--primary); }

  /* ── In iframe (modal) ── */
  @media (max-height: 700px), (max-width: 1100px) {
    header { display: none; }
    main { margin-top: 0; }
  }

  /* ── Responsive ── */
  @media (max-width: 900px) {
    .toc { display: none; }
    main { margin-left: 0; }
    .bottom-nav { left: 0; }
    .chapter { padding: 36px 20px 120px; }
    .compare { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>

<header>
  <h1>ETF Atlas <span>Story</span></h1>
  <div class="nav-controls">
    <button class="nav-btn" id="prevBtn" onclick="go(-1)">&larr;</button>
    <span class="page-info" id="pageInfo">1 / 7</span>
    <button class="nav-btn" id="nextBtn" onclick="go(1)">&rarr;</button>
  </div>
</header>

<aside class="toc" id="toc"></aside>

<main>

<!-- ═══════════════ Chapter 1: 오프닝 ═══════════════ -->
<section class="chapter" data-title="오프닝">
  <div class="chapter-num">Chapter 01</div>
  <h2 class="chapter-title">오프닝</h2>
  <div class="chapter-divider"></div>

  <p>안녕하세요. 오늘은 <span class="hl">리서치 프로젝트</span>로 진행한 <span class="hl-blue">ETF Atlas</span>를 소개하면서, 그 과정에서 사용한 기술들에 대해 이야기하려 합니다.</p>

  <h3 class="sub-title">문제 제기</h3>
  <p>본격적인 기술 소개에 앞서, 왜 이런 기술이 필요한지부터 짚어보겠습니다.</p>
  <p>한국 ETF가 약 <span class="hl">900개</span>인데, 그중 순자산 기준으로 걸러낸 우리 유니버스만 해도 수백 개이고, 보유종목이 수천 개입니다. 이 데이터에서 의미 있는 정보를 뽑으려면 <span class="hl-blue">관계를 탐색</span>해야 합니다.</p>
  <p>예를 들어 "삼성전자를 가장 많이 보유한 ETF는?" 이라는 질문은 관계형 DB에서 <span class="tech">JOIN</span> 3개에 <span class="tech">GROUP BY</span>, <span class="tech">ORDER BY</span>를 써야 합니다. "KODEX 200과 비슷한 ETF는?"은 자기 조인에 서브쿼리, <span class="tech">HAVING</span>까지 필요합니다. 쿼리가 복잡해질수록 성능과 가독성 모두 떨어집니다.</p>
  <p>거기에 한 가지 더 욕심을 내봤습니다. 이런 복잡한 질문을 개발자가 아닌 일반 사용자도 할 수 있으면 어떨까? <span class="hl">"반도체 ETF 중 보수율 낮은 것 알려줘"</span>라고 자연어로 물어보면 알아서 데이터를 찾아 답해주는 챗봇을 만들고 싶었습니다.</p>

  <div class="callout">이 두 가지 &mdash; <strong>복잡한 관계 탐색</strong>과 <strong>자연어 질의</strong> &mdash; 를 해결하기 위해 선택한 기술이 <strong>Apache AGE</strong>와 <strong>smolagents</strong>입니다. 여기에 데이터 수집 자동화를 위한 <strong>Apache Airflow</strong>까지, 이 세 가지 기술의 실제 적용 경험을 공유하겠습니다.</div>

  <h3 class="sub-title">기술 선택 배경</h3>
  <p>이 프로젝트는 <span class="hl">회사에서 기술 리서치 차원</span>으로 진행했습니다. 주제는 평소 관심이 있던 ETF 투자로 잡았는데, 실제 서비스에 가까운 도메인으로 기술을 검증해야 리서치 결과가 의미 있다고 생각했기 때문입니다.</p>
  <p>리서치 대상 기술은 세 가지입니다.</p>
  <ul>
    <li><span class="hl-blue">그래프 데이터베이스</span> &mdash; ETF 데이터는 본질적으로 관계 중심. Neo4j 대신 PostgreSQL 확장인 <span class="tech">Apache AGE</span> 선택</li>
    <li><span class="hl-purple">LLM 에이전트 프레임워크</span> &mdash; LangChain은 추상화가 무거워서 경량 프레임워크인 <span class="tech">smolagents</span> 선택</li>
    <li><span class="hl-green">데이터 파이프라인</span> &mdash; 배치 중심 워크로드에 Python 네이티브인 <span class="tech">Apache Airflow</span> 선택</li>
  </ul>

  <div class="callout">이 세 기술이 실제 서비스 수준의 프로젝트에서 얼마나 쓸 만한지 직접 검증해 보는 것이 이번 리서치의 목표였습니다.</div>
</section>

<!-- ═══════════════ Chapter 2: Apache AGE ═══════════════ -->
<section class="chapter" data-title="Apache AGE 기술 소개">
  <div class="chapter-num">Chapter 02</div>
  <h2 class="chapter-title">Apache AGE 기술 소개</h2>
  <div class="chapter-divider"></div>

  <h3 class="sub-title">Apache AGE란?</h3>
  <p><span class="hl-blue">Apache AGE</span>는 Apache Software Foundation의 인큐베이팅 프로젝트로, PostgreSQL에 그래프 데이터베이스 기능을 추가하는 확장(Extension)입니다. 이름 자체가 <span class="hl">"A Graph Extension"</span>의 약자입니다.</p>
  <p>핵심 특징은 세 가지입니다.</p>
  <ul>
    <li><strong>PostgreSQL 위에서 동작</strong> &mdash; 별도 DB를 띄울 필요 없이 확장만 설치하면 됩니다</li>
    <li><strong>Cypher 쿼리 지원</strong> &mdash; Neo4j에서 쓰던 그 Cypher 문법 그대로 쓸 수 있습니다</li>
    <li><strong>SQL + Cypher 혼용</strong> &mdash; 기존 관계형 테이블과 그래프 데이터를 하나의 DB에서 조회 가능</li>
  </ul>
  <p>라이선스는 <span class="hl-green">Apache 2.0</span>으로, 상용 환경에서도 자유롭게 사용 가능합니다.</p>

  <h3 class="sub-title">Neo4j vs Apache AGE</h3>
  <div class="compare">
    <div class="compare-card">
      <h4>Neo4j</h4>
      <ul>
        <li>전용 그래프 DB, 성능과 기능 면에서 가장 성숙</li>
        <li>Community Edition은 AGPL, Enterprise는 상용 라이선스</li>
        <li>별도 서버 운영 필요</li>
        <li>RDBMS와 데이터 분리 관리</li>
      </ul>
    </div>
    <div class="compare-card">
      <h4>Apache AGE</h4>
      <ul>
        <li>PostgreSQL 확장 &mdash; 기존 인프라 그대로 활용</li>
        <li><span class="hl-green">Apache 2.0</span> 라이선스</li>
        <li>하나의 DB에서 관계형 + 그래프</li>
        <li>Cypher 지원 불완전, 에코시스템 작음</li>
      </ul>
    </div>
  </div>
  <div class="callout">이미 PostgreSQL을 쓰고 있고, 그래프 쿼리가 핵심 워크로드의 일부라면 AGE가 합리적인 선택입니다.</div>

  <h3 class="sub-title">AGE 동작 방식</h3>
  <p>일반 SQL 안에 <span class="tech">cypher()</span> 함수를 호출하는 형태입니다.</p>
<pre>SELECT * FROM cypher('etf_graph', $$
    MATCH (e:ETF)-[h:HOLDS]->(s:Stock)
    WHERE e.code = '069500'
    RETURN {stock: s.name, weight: h.weight}
$$) as (result agtype);</pre>
  <div class="callout-warn">
    <strong>주의할 점:</strong> 그래프 이름 지정 필수, 결과 타입은 <span class="tech">agtype</span>, RETURN 값이 여러 개일 때는 <span class="hl">맵으로 감싸야</span> 합니다 (단일 컬럼 반환).
  </div>
</section>

<!-- ═══════════════ Chapter 3: smolagents ═══════════════ -->
<section class="chapter" data-title="smolagents 기술 소개">
  <div class="chapter-num">Chapter 03</div>
  <h2 class="chapter-title">smolagents 기술 소개</h2>
  <div class="chapter-divider"></div>

  <h3 class="sub-title">smolagents란?</h3>
  <p><span class="hl-purple">smolagents</span>는 Hugging Face에서 만든 경량 AI 에이전트 프레임워크입니다. 2024년 말에 공개됐고, 핵심 철학은 <span class="hl">"최소한의 추상화"</span>입니다.</p>
  <p>LangChain이 모든 것을 추상화하려는 접근이라면, smolagents는 필요한 것만 제공하고 나머지는 개발자가 직접 제어하는 방식입니다.</p>
  <p>핵심 구성 요소는 세 가지입니다.</p>
  <ul>
    <li><strong>Model</strong> &mdash; 에이전트의 두뇌 역할을 하는 LLM. OpenAI, Anthropic 등 다양한 모델을 플러그인 방식으로 연결</li>
    <li><strong>Tool</strong> &mdash; 에이전트가 실행할 수 있는 도구. <span class="tech">name</span>, <span class="tech">description</span>, <span class="tech">inputs</span>, <span class="tech">output_type</span>, <span class="tech">forward()</span> 다섯 가지만 정의</li>
    <li><strong>Agent</strong> &mdash; Model과 Tool을 조합하는 실행 주체. <span class="hl-purple">CodeAgent</span>는 Python 코드를 직접 생성해서 도구 호출</li>
  </ul>
  <div class="callout">Model + Tool + Agent, 이 세 가지가 전부입니다.</div>

  <h3 class="sub-title">LangChain vs smolagents</h3>
  <div class="compare">
    <div class="compare-card">
      <h4>LangChain</h4>
      <ul>
        <li>풍부한 에코시스템 (수백 개 통합)</li>
        <li>추상화 레이어가 깊어 디버깅 어려움</li>
        <li>간단한 기능도 여러 클래스 필요</li>
        <li>breaking change 잦음</li>
      </ul>
    </div>
    <div class="compare-card">
      <h4>smolagents</h4>
      <ul>
        <li>코어가 작고 코드를 직접 읽을 수 있을 만큼 단순</li>
        <li>Tool 하나, Agent 하나면 시작 가능</li>
        <li>에코시스템 작음, 고급 기능은 직접 구현</li>
        <li>도구 호출 중심 에이전트에 빠른 프로토타이핑</li>
      </ul>
    </div>
  </div>
</section>

<!-- ═══════════════ Chapter 4: Apache Airflow ═══════════════ -->
<section class="chapter" data-title="Apache Airflow 기술 소개">
  <div class="chapter-num">Chapter 04</div>
  <h2 class="chapter-title">Apache Airflow 기술 소개</h2>
  <div class="chapter-divider"></div>

  <h3 class="sub-title">Apache Airflow란?</h3>
  <p><span class="hl-green">Apache Airflow</span>는 데이터 파이프라인을 작성하고, 스케줄링하고, 모니터링하는 플랫폼입니다. Airbnb에서 2014년에 만들었고, 지금은 Apache 최상위 프로젝트입니다.</p>
  <p>핵심 개념은 네 가지입니다.</p>
  <ul>
    <li><strong>DAG</strong> &mdash; Directed Acyclic Graph. 작업 흐름을 Python 코드로 정의한 것</li>
    <li><strong>Task</strong> &mdash; DAG 안에서 실행되는 개별 작업 단위</li>
    <li><strong>Operator</strong> &mdash; Task가 "무엇을 할지" 정의하는 템플릿 (<span class="tech">PythonOperator</span>, <span class="tech">ShortCircuitOperator</span> 등)</li>
    <li><strong>Scheduler</strong> &mdash; DAG 스케줄에 따라 작업을 자동 트리거하는 엔진</li>
  </ul>

  <h3 class="sub-title">왜 Airflow를 선택했나 &mdash; NiFi와의 비교</h3>
  <div class="compare">
    <div class="compare-card">
      <h4>NiFi</h4>
      <ul>
        <li>NSA에서 만든 데이터 흐름 관리 시스템</li>
        <li><span class="hl">실시간 데이터 라우팅</span>에 초점</li>
        <li>GUI 드래그 앤 드롭으로 파이프라인 구성</li>
        <li>IoT, 로그 수집, 실시간 전달에 강함</li>
      </ul>
    </div>
    <div class="compare-card">
      <h4>Airflow</h4>
      <ul>
        <li>Airbnb에서 만든 워크플로우 오케스트레이터</li>
        <li><span class="hl">배치 작업 오케스트레이션</span>에 초점</li>
        <li>Python 코드로 워크플로우 정의 &rarr; Git 버전 관리 가능</li>
        <li>배치 ETL, 정기 수집, ML 파이프라인에 강함</li>
      </ul>
    </div>
  </div>
  <div class="callout">"평일 장 마감 후에 KRX에서 데이터를 가져와서 가공한 뒤 DB에 적재한다." &mdash; 전형적인 배치 작업. Python 네이티브인 Airflow가 자연스러운 선택.</div>
</section>

<!-- ═══════════════ Chapter 5: 적용 사례 ═══════════════ -->
<section class="chapter" data-title="ETF Atlas 적용 사례">
  <div class="chapter-num">Chapter 05</div>
  <h2 class="chapter-title">ETF Atlas 프로젝트 적용 사례</h2>
  <div class="chapter-divider"></div>

  <h3 class="sub-title">프로젝트 개요</h3>
  <p><span class="hl-blue">ETF Atlas</span>는 한국 ETF 정보를 수집하고, 분석하고, AI 챗봇으로 질의할 수 있는 서비스입니다.</p>
  <ul>
    <li><strong>ETF 탐색</strong> &mdash; 테마별 분류, 검색, 유사 ETF 찾기</li>
    <li><strong>포트폴리오 관리</strong> &mdash; ETF/주식 매수 기록, 목표 비중 설정, 수익률 추적</li>
    <li><strong>워치리스트</strong> &mdash; 관심 ETF 등록, 보유종목 변동 알림</li>
    <li><strong>AI 챗봇</strong> &mdash; 자연어로 ETF 데이터 질의</li>
  </ul>
  <p>관심 있는 도메인에 리서치 대상 기술을 적용해서 <span class="hl">실전 수준으로 검증</span>한 프로젝트입니다.</p>

  <h3 class="sub-title">전체 아키텍처</h3>
  <p>시스템은 <span class="hl">4개의 Docker 컨테이너</span>로 구성됩니다.</p>
  <ul>
    <li><strong>DB</strong> &mdash; PostgreSQL 17 + Apache AGE + pgvector</li>
    <li><strong>Backend</strong> &mdash; FastAPI (Python) + smolagents</li>
    <li><strong>Frontend</strong> &mdash; React + TypeScript + Vite</li>
    <li><strong>Airflow</strong> &mdash; 데이터 수집 파이프라인</li>
  </ul>
  <div class="callout">하나의 PostgreSQL에 관계형 테이블과 그래프 데이터가 공존합니다. CRUD는 관계형 테이블, 관계 탐색은 그래프 &mdash; 이게 Apache AGE의 가장 큰 장점입니다.</div>

  <h3 class="sub-title">데이터 파이프라인 &mdash; Airflow 활용</h3>
  <p>ETF Atlas에서는 <span class="hl">5개의 Airflow DAG</span>를 운영하고 있습니다.</p>
  <ul>
    <li><strong>일별 ETF 동기화 (AGE)</strong> &mdash; 거래일 다음날 새벽 4시, KRX 데이터 수집 &rarr; ETF/Price 노드 생성 &rarr; HOLDS 관계 &rarr; 수익률 계산 &rarr; Discord 알림</li>
    <li><strong>실시간 가격 수집 (RDB)</strong> &mdash; 평일 장중 10분마다, <span class="tech">ShortCircuitOperator</span>로 장 오픈 여부 판단 후 실행</li>
    <li><strong>주간 태깅 (AGE)</strong> &mdash; 토요일 새벽 3시, 규칙 기반 + 키워드 매칭 + LLM 분류 3단계 전략</li>
    <li><strong>RDB 메타데이터 동기화</strong> &mdash; 평일 오전 7시, KRX에서 ETF 코드/이름 동기화</li>
    <li><strong>백필 (AGE)</strong> &mdash; 수동 실행, 과거 거래일 데이터 한꺼번에 수집 (보유종목 수집에 6시간 타임아웃)</li>
  </ul>

  <h3 class="sub-title">Airflow에서 유용했던 기능들</h3>
  <ul>
    <li><span class="hl-green">자동 재시도</span> &mdash; <span class="tech">retries=3, retry_delay=timedelta(minutes=5)</span>만 설정하면 5분 간격 3번 자동 재시도</li>
    <li><span class="hl-green">XCom</span> &mdash; Task 간 데이터 전달. "거래일 목록 조회" Task가 날짜 리스트를 반환하면 다음 Task가 수신</li>
    <li><span class="hl-green">웹 UI</span> &mdash; 실행 이력, 성공/실패 상태, 로그 확인. 실패한 Task만 골라서 재실행 가능</li>
    <li><span class="hl-green">병렬 실행</span> &mdash; 의존 관계 없는 Task는 자동 병렬 실행</li>
    <li><span class="hl-green">Configuration as Code</span> &mdash; DAG가 Python 코드 &rarr; Git 버전 관리, 코드 리뷰 가능</li>
  </ul>

  <h3 class="sub-title">그래프 데이터 모델링</h3>
  <p>노드 6종류, 관계 5종류:</p>
  <ul>
    <li><span class="tech">ETF</span>, <span class="tech">Stock</span>, <span class="tech">Price</span>, <span class="tech">Company</span>, <span class="tech">Tag</span>, <span class="tech">User</span></li>
    <li><span class="tech">HOLDS</span>, <span class="tech">HAS_PRICE</span>, <span class="tech">MANAGED_BY</span>, <span class="tech">TAGGED</span>, <span class="tech">WATCHES</span></li>
  </ul>
  <div class="callout">"삼성전자를 보유한 ETF 중에서 반도체 태그가 달린 것" 같은 질의를 MATCH 패턴 하나로 표현할 수 있습니다.</div>

  <h3 class="sub-title">Cypher 쿼리 실전 예시</h3>
  <p><strong>유사 ETF 찾기</strong> &mdash; 공통 보유종목의 비중 최솟값을 합산해 유사도 계산:</p>
<pre>MATCH (e1:ETF {code: '069500'})-[h1:HOLDS]->(s:Stock)
MATCH (e2:ETF)-[h2:HOLDS]->(s) WHERE e1 <> e2
WITH e2, COUNT(s) as overlap,
     SUM(CASE WHEN h1.weight < h2.weight
         THEN h1.weight ELSE h2.weight END) as similarity
RETURN {code: e2.code, name: e2.name,
        overlap: overlap, similarity: similarity}
ORDER BY similarity DESC LIMIT 5</pre>
  <div class="callout-warn">관계형 DB였다면 자기 조인 + GROUP BY + HAVING으로 복잡해질 쿼리가, 그래프에서는 <span class="hl">MATCH 패턴</span>으로 자연스럽게 표현됩니다.</div>

  <h3 class="sub-title">AI 챗봇 &mdash; 전체 구조</h3>
  <p><span class="tech">ChatService</span> 클래스가 핵심. 두 가지 실행 경로:</p>
  <ul>
    <li><strong>단순 질문</strong> &rarr; smolagents <span class="hl-purple">CodeAgent</span>가 <span class="hl">ReAct 방식</span>으로 처리</li>
    <li><strong>복잡한 질문</strong> &rarr; <span class="hl">Plan-Execute-Summarize</span> 방식으로 처리</li>
  </ul>
  <p>모델은 LiteLLM을 통해 <span class="tech">GPT-4.1-mini</span> 사용, <span class="hl">10개의 커스텀 Tool</span> 등록.</p>
  <ul>
    <li><strong>검색:</strong> ETF 검색, 종목 검색, 태그 목록</li>
    <li><strong>정보:</strong> ETF 상세, ETF 가격, 주식 가격, 보유종목 변동</li>
    <li><strong>분석:</strong> 유사 ETF, ETF 비교, 직접 Cypher 쿼리</li>
  </ul>
  <div class="callout">모든 도구가 내부적으로 Apache AGE 그래프를 조회합니다. 두 기술(Apache AGE, smolagents)이 여기서 만납니다.</div>

  <h3 class="sub-title">AI 챗봇 &mdash; CodeAgent 동작 흐름</h3>
  <ul>
    <li><strong>1단계:</strong> 사용자가 "삼성전자를 가장 많이 보유한 ETF는?" 질문</li>
    <li><strong>2단계:</strong> 에이전트가 Python 코드 생성</li>
    <li><strong>3단계:</strong> 코드 실행 &rarr; 도구 호출</li>
    <li><strong>4단계:</strong> 실행 결과로 최종 답변 생성</li>
  </ul>
<pre>result = stock_search("삼성전자")
stock_code = json.loads(result)[0]["code"]
holdings = graph_query(
    "MATCH (e:ETF)-[h:HOLDS]->(s:Stock {code: '"
    + stock_code + "'}) ..."
)</pre>
  <p>최대 <span class="hl">10스텝</span>까지 반복. 에러 시 에이전트가 스스로 코드를 수정해서 재시도합니다.</p>

  <h3 class="sub-title">AI 챗봇 &mdash; Plan-Execute-Summarize</h3>
  <p>복잡한 질문에서 CodeAgent가 방향을 잃는 문제 &rarr; <span class="hl">질의 복잡도에 따라 실행 경로를 분기</span>:</p>
  <ul>
    <li>예상 도구 호출 <strong>3회 이하</strong> &rarr; 기존 ReAct</li>
    <li>예상 도구 호출 <strong>4회 이상</strong> &rarr; Plan-Execute-Summarize</li>
  </ul>
  <div class="callout">
    <strong>Plan:</strong> LLM이 실행 계획을 JSON으로 생성 (<span class="tech">$results[0].code</span> 처럼 변수 참조)<br>
    <strong>Execute:</strong> 계획대로 도구를 순차 실행, 변수 치환<br>
    <strong>Summarize:</strong> 수집된 결과를 LLM이 종합해서 최종 답변 생성
  </div>

  <h3 class="sub-title">AI 챗봇 &mdash; Tool 정의</h3>
<pre>class ETFSearchTool(Tool):
    name = "etf_search"
    description = "ETF를 이름이나 코드로 검색합니다"
    inputs = {
        "query": {"type": "string", "description": "검색어"},
        "limit": {"type": "integer", "description": "결과 수"}
    }
    output_type = "string"

    def forward(self, query: str, limit: int = 10) -> str:
        graph = GraphService(self.db)
        results = graph.search_etfs(query, limit)
        return json.dumps(results, ensure_ascii=False)</pre>
  <div class="callout-warn"><strong>핵심은 description</strong> &mdash; 에이전트가 이 설명을 보고 어떤 도구를 호출할지 결정합니다.</div>

  <h3 class="sub-title">AI 챗봇 &mdash; Few-shot 학습</h3>
  <p><span class="hl">100여 개의 Cypher 쿼리 예시</span>를 <span class="tech">pgvector</span>에 임베딩으로 저장. 사용자 질문과 유사한 3개의 예시를 벡터 검색으로 찾아 프롬프트에 주입합니다.</p>
  <div class="callout">같은 PostgreSQL 안에서 <span class="hl-blue">벡터 검색</span>과 <span class="hl-blue">그래프 쿼리</span>가 동시에 일어납니다.</div>

  <h3 class="sub-title">포트폴리오 관리 & 대시보드</h3>
  <p>ETF/주식 매수 기록 &rarr; 현재 가격 기반 포트폴리오 가치 계산. 목표 비중 설정 시 실제 비중과의 괴리를 표시.</p>
  <p>대시보드에서는 <span class="tech">Recharts</span>로 가치 변화 시각화. <span class="tech">portfolio_snapshots</span> 테이블에 일별 스냅샷, Airflow가 가격 수집 후 자동 스냅샷.</p>
  <div class="callout-green">CRUD 중심 데이터는 <strong>관계형</strong>으로, 관계 탐색은 <strong>그래프</strong>로 &mdash; 모든 것을 그래프에 넣지 않는 분리 설계.</div>
</section>

<!-- ═══════════════ Chapter 6: 시행착오 ═══════════════ -->
<section class="chapter" data-title="시행착오">
  <div class="chapter-num">Chapter 06</div>
  <h2 class="chapter-title">시행착오</h2>
  <div class="chapter-divider"></div>

  <h3 class="sub-title">smolagents &mdash; 프롬프트 엔지니어링의 중요성</h3>
  <p>smolagents에서 <span class="hl">가장 어려웠던 건 기술이 아니라 프롬프트</span>였습니다.</p>
  <p>도구의 <span class="tech">description</span>을 어떻게 쓰느냐에 따라 에이전트의 도구 선택 정확도가 크게 달라집니다.</p>
  <div class="compare">
    <div class="compare-card" style="border-color: var(--red);">
      <h4 style="color: var(--red);">Before</h4>
      <p>"ETF를 검색합니다" &rarr; 에이전트가 ETF 검색 대신 직접 Cypher 쿼리를 날리는 경우가 많았음</p>
    </div>
    <div class="compare-card" style="border-color: var(--green);">
      <h4 style="color: var(--green);">After</h4>
      <p>"코드나 이름의 일부로 ETF를 검색합니다. 전체 목록이 아닌 <span class="hl">특정 ETF를 찾을 때</span> 사용하세요." &rarr; 정확도 향상</p>
    </div>
  </div>
  <div class="callout-warn">시스템 프롬프트에 <span class="hl">"태그 이름을 사용하기 전에 반드시 list_tags를 먼저 호출하세요"</span> 같은 규칙을 명시해야 합니다. 안 그러면 에이전트가 태그 이름을 추측해서 잘못된 쿼리를 만듭니다.</div>

  <h3 class="sub-title">가격 데이터 이전 &mdash; RDB에서 AGE로</h3>
  <p>처음에는 <span class="tech">etf_prices</span>, <span class="tech">stock_prices</span> 관계형 테이블에 가격을 저장. 챗봇을 만들면서 문제 발생 &mdash; 모든 도구는 AGE 그래프만 조회하는데, 가격만 RDB에 있어서 SQL과 Cypher를 오가야 했습니다.</p>
  <p>해결: <span class="tech">Price</span> 노드 + <span class="tech">HAS_PRICE</span> 관계를 추가하고 RDB 테이블은 제거. 가격 서비스는 <span class="hl">4단계 폴백 전략</span>:</p>
  <ul>
    <li>60초 캐시 &rarr; 당일 AGE Price 노드 &rarr; yfinance API &rarr; AGE 최신 Price 노드</li>
  </ul>
  <div class="callout">데이터 저장소는 <strong>"어디서 주로 조회하느냐"</strong>에 맞춰야 합니다. 챗봇이 주 소비자라면, 챗봇이 접근하는 저장소에 데이터를 두는 게 자연스럽습니다.</div>

  <h3 class="sub-title">그래프 vs 관계형 &mdash; 어디에 뭘 넣을까</h3>
  <div class="compare">
    <div class="compare-card">
      <h4>그래프에 적합</h4>
      <ul>
        <li>관계 탐색 (ETF-종목 보유, 유사 ETF, 태그 분류)</li>
        <li>시계열 + 관계 (날짜별 보유종목 비중 변화)</li>
        <li>다대다 관계 (사용자-ETF 워치리스트)</li>
      </ul>
    </div>
    <div class="compare-card">
      <h4>관계형에 적합</h4>
      <ul>
        <li>단순 CRUD (사용자 정보, 포트폴리오, 매수 기록)</li>
        <li>집계/정렬 중심 조회 (스냅샷, 가치 계산)</li>
        <li>트랜잭션이 중요한 데이터 (인증, 주문)</li>
      </ul>
    </div>
  </div>
  <div class="callout-green"><strong>"전부 그래프" 또는 "전부 관계형"이 아니라 데이터 특성에 맞게 섞어 쓰는 게 현실적인 접근.</strong> Apache AGE의 장점이 바로 이 분리를 한 DB에서 할 수 있다는 것입니다.</div>
</section>

<!-- ═══════════════ Chapter 7: 회고 & 마무리 ═══════════════ -->
<section class="chapter" data-title="회고 & 마무리">
  <div class="chapter-num">Chapter 07</div>
  <h2 class="chapter-title">회고 & 마무리</h2>
  <div class="chapter-divider"></div>

  <h3 class="sub-title">기술 선택 회고</h3>
  <p>프로젝트를 마치며 각 기술에 대한 솔직한 평가입니다.</p>

  <div class="review-card">
    <h4><span class="hl-blue">Apache AGE</span></h4>
    <div class="review-section">
      <div class="review-label good">Good</div>
      <p>PostgreSQL 하나로 <span class="hl">관계형 + 그래프 + 벡터 검색</span>까지 가능. 인프라 복잡도가 획기적으로 줄어듭니다.</p>
    </div>
    <div class="review-section">
      <div class="review-label bad">Bad</div>
      <p>Cypher 지원이 Neo4j 대비 불완전. ORM 통합 가이드가 거의 없어서 삽질이 많았습니다. 커뮤니티도 아직 작습니다.</p>
    </div>
    <div class="review-section">
      <div class="review-label rec">Recommend</div>
      <p>이미 PostgreSQL을 쓰고 있고, 그래프 쿼리가 전체 워크로드의 일부일 때.</p>
    </div>
  </div>

  <div class="review-card">
    <h4><span class="hl-purple">smolagents</span></h4>
    <div class="review-section">
      <div class="review-label good">Good</div>
      <p>도구 정의가 직관적이고, CodeAgent의 코드 생성 방식이 유연합니다. 소스 코드가 읽을 만한 수준으로 작아서 내부 동작을 이해하기 쉽습니다.</p>
    </div>
    <div class="review-section">
      <div class="review-label bad">Bad</div>
      <p>문서가 부족하고, 고급 기능은 직접 구현해야 합니다. 프롬프트 의존도가 높아서 튜닝에 시간이 많이 듭니다.</p>
    </div>
    <div class="review-section">
      <div class="review-label rec">Recommend</div>
      <p>도구 호출 중심의 에이전트를 빠르게 만들고 싶을 때. 복잡한 RAG 파이프라인이 필요하면 LangChain이 나을 수 있습니다.</p>
    </div>
  </div>

  <div class="review-card">
    <h4><span class="hl-green">Apache Airflow</span></h4>
    <div class="review-section">
      <div class="review-label good">Good</div>
      <p>작업 흐름을 Python 코드로 관리할 수 있다는 것 자체가 큰 가치. 웹 UI, 자동 재시도, 병렬 실행, XCom이 설정만으로 동작합니다.</p>
    </div>
    <div class="review-section">
      <div class="review-label bad">Bad</div>
      <p>초기 설정이 번거롭습니다. "Hello World"까지 단계가 많지만, Docker로 한번 세팅하면 이후에는 DAG 파일만 관리.</p>
    </div>
    <div class="review-section">
      <div class="review-label rec">Recommend</div>
      <p>Python 기반 배치 ETL, 정기 데이터 수집 파이프라인. 실시간 데이터 라우팅이 핵심이라면 NiFi가 더 적합합니다.</p>
    </div>
  </div>

  <div style="text-align: center; margin-top: 60px; padding: 40px 0; border-top: 2px solid var(--border);">
    <p style="font-size: 20px; font-weight: 600; color: var(--text);">감사합니다.</p>
    <p style="color: var(--text-secondary); margin-top: 8px;">질문 받겠습니다.</p>
  </div>
</section>

</main>

<!-- ── Bottom nav ── -->
<div class="bottom-nav">
  <button class="bottom-btn" id="bottomPrev" onclick="go(-1)">
    &larr; 이전
  </button>
  <div class="dots" id="dots"></div>
  <button class="bottom-btn primary" id="bottomNext" onclick="go(1)">
    다음 &rarr;
  </button>
</div>

<script>
  const chapters = document.querySelectorAll('.chapter');
  const toc = document.getElementById('toc');
  const dots = document.getElementById('dots');
  let current = 0;

  // Build TOC & dots
  chapters.forEach((ch, i) => {
    const title = ch.dataset.title;
    const item = document.createElement('a');
    item.className = 'toc-item';
    item.innerHTML = '<span class="toc-num">' + String(i + 1).padStart(2, '0') + '</span> ' + title;
    item.onclick = () => goTo(i);
    toc.appendChild(item);

    const dot = document.createElement('button');
    dot.className = 'dot';
    dot.onclick = () => goTo(i);
    dots.appendChild(dot);
  });

  function goTo(idx) {
    if (idx < 0 || idx >= chapters.length) return;
    chapters[current].classList.remove('active');
    current = idx;
    chapters[current].classList.add('active');
    updateUI();
    window.scrollTo({ top: 0, behavior: 'instant' });
  }

  function go(dir) { goTo(current + dir); }

  function updateUI() {
    document.getElementById('pageInfo').textContent = (current + 1) + ' / ' + chapters.length;
    document.getElementById('prevBtn').disabled = current === 0;
    document.getElementById('nextBtn').disabled = current === chapters.length - 1;
    document.getElementById('bottomPrev').disabled = current === 0;
    document.getElementById('bottomNext').disabled = current === chapters.length - 1;

    toc.querySelectorAll('.toc-item').forEach((item, i) => {
      item.classList.toggle('active', i === current);
    });
    dots.querySelectorAll('.dot').forEach((dot, i) => {
      dot.classList.toggle('active', i === current);
    });
  }

  // Keyboard nav
  document.addEventListener('keydown', (e) => {
    if (e.key === 'ArrowLeft') go(-1);
    if (e.key === 'ArrowRight') go(1);
  });

  // Init
  goTo(0);
</script>

</body>
</html>
